{
	function create_rule(needed, given) {
		return {needed, given};
	};

	function to_exp(value, type, left, right) {
		if (value)
			return {type: 'value', value};
		return {type, left, right};
	};

	function to_not(v) {
		return {type: '!', v}
	}
}

start
	= rules+ ;

rules
	= _ws_ needed:exp _ws_ '=>' _ws_ given:exp _ws_ _nl_ {return create_rule(needed, given)} ;

exp
	= and
	/ or
	/ xor
	/ eval ;

and
	= l:eval _ws_ '+' _ws_ m:eval _ws_ o:('|' / '^') _ws_ r:exp
	{console.log('AND1'); return to_exp(null, o, to_exp(null, '+', l, m), r)}
	/ l:eval _ws_ '+' _ws_ r:exp
	{console.log('AND2'); return to_exp(null, '+', l, r)} ;
or
	= l:eval _ws_ '|' _ws_ r:exp
	{console.log('OR1'); return to_exp(null, '|', l, r)} ;
xor
	= l:exp _ws_ '^' _ws_ r:exp
	{console.log('XOR1'); return to_exp(null, '^', l, r)} ;

eval
	= '!(' _ws_ v:exp _ws_ ')' {return to_not(v)}
	/ '(' _ws_ v:exp _ws_ ')' {return v}
	/ v:fact {return to_exp(v)} 
	/ '!' v:fact {return to_not(to_exp(v))} ;

fact
	= [A-Z] ;

_ws_
	= (' ' / '\t')* ;

_nl_
	= ('\n')+ ;